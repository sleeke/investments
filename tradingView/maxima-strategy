// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© BritishBritishColumbian


//@version=4
strategy(
     "Local Maxima",
     overlay=true, 
     margin_long=0, 
     margin_short=0, 
     default_qty_type=strategy.percent_of_equity, 
     default_qty_value=100)


// -------//
// Inputs //
// -------//

// The number of sessions to use for the maxima/minima
studyRange = input(       
     title="Number of sessions either side of local maxima/minima", 
     type=input.integer, 
     defval=2, 
     minval=1, 
     maxval=100)

requiredDeltaPercent = input(       
     title="percent change required for local maxima/minima", 
     type=input.float, 
     defval=0, 
     minval=0, 
     maxval=10)

compliantMovingAveragePeriod = input(       
     title="moving average period which indicates trend", 
     type=input.integer, 
     defval=50, 
     minval=1, 
     maxval=200)

// The required percentage trend in the moving average to initiate a 'buy' signal (only buy on positive trend)
maTrendPercent = input(
     title="Required MA trend percent for buy signal", 
     type=input.float, 
     defval=0.028, 
     minval=-100, 
     maxval=100)

dateRange = input(
     title="Date range to strategize over (years)", 
     type=input.float, 
     defval=1, 
     minval=0, 
     maxval=5)

// ---------------------------//
// Maxima/minima calculation //
// ---------------------------//

varip maximaHistory = array.new_float(2, 0.0)
varip minimaHistory = array.new_float(2, 0.0)

minimaStudyPeriod = array.new_float()
maximaStudyPeriod = array.new_float()
for i = 0 to studyRange * 2
	array.push(minimaStudyPeriod, low[i])
	array.push(maximaStudyPeriod, high[i])


localMinima = array.min(minimaStudyPeriod)
localMaxima = array.max(maximaStudyPeriod)
deltaPercent = abs(localMaxima / localMinima - 1) * 100

minimaFound = 0
maximaFound = 0


if (array.get(maximaStudyPeriod, studyRange) >= localMaxima and deltaPercent > requiredDeltaPercent)
    array.shift(maximaHistory)
    array.push(maximaHistory, localMaxima)
    maximaFound := 1
    // array.shift(minimaHistory)
    // array.push(minimaHistory, 0.0)
    

if (array.get(minimaStudyPeriod, studyRange) <= localMinima and deltaPercent > requiredDeltaPercent)
    array.shift(minimaHistory)
    array.push(minimaHistory, localMinima)
    minimaFound := 1
    // array.shift(maximaHistory)
    // array.push(maximaHistory, 0.0)


// --------------//
// Study outputs //
// --------------//

// Plot colors
priceAboveMaximaColorInput = input(#53A4F3, "Price above last maxima", input.color)
positiveColor = color.new(#51B561, 30)
positiveFadedColor = color.new(positiveColor, 70)
priceAboveMinimaColorInput = input(#825FC2, "Price above last minima", input.color)
negativeColor = color.new(#FA4040, 50)
negativeFadedColor = color.new(negativeColor, 80)

maximaDeltaColorInput = input(#53A4F3, "Maxima delta", input.color)
minimaDeltaColorInput = input(#825FC2, "Minima delta", input.color)


priceAboveLastMinima = low - array.get(minimaHistory, 1)
priceAboveLastMaxima = high - array.get(maximaHistory, 1)

minimaDiff = array.get(minimaHistory, 1) / array.get(minimaHistory, 0) - 1
maximaDiff = array.get(maximaHistory, 1) / array.get(maximaHistory, 0) - 1

minimaFound := minimaFound * (minimaDiff >= 0 ? 1 : -1)
maximaFound := maximaFound * (maximaDiff >= 0 ? 1 : -1)

ma = sma(open, compliantMovingAveragePeriod)
trend = ma / ma[1] - 1
sufficientMaTrend = trend > (maTrendPercent / 100)                                      // Is there sufficent Moving Average trend to buy?

exitSignal = 0.0
// if maximaDiff < 0 and priceAboveLastMaxima < 0 
//     exitSignal := -1//abs(maximaDiff)
    
if priceAboveLastMinima < 0
    exitSignal := -1//abs(minimaCloseDiff)
    
if sufficientMaTrend == false
    exitSignal := -1
    
enterSignal = 0.0
if exitSignal == 0.0 and sufficientMaTrend// and exitSignal[1] == 0.0
    if priceAboveLastMaxima > 0.0 
        enterSignal := 1//max(0, maximaDiff - minimaCloseDiff, maximaCloseDiff) // max(maximaCloseDiff, minimaDiff)
        
    if minimaDiff > 0.0 and priceAboveLastMinima > 0.0
        enterSignal := 1

// --------//
// Actions //
// --------//

pastStartDate = time > timenow - (1000 *60 * 60 * 24 * 365 * dateRange) 

if (pastStartDate and enterSignal)// > 0 and sufficientMaTrend)
    strategy.entry("Long", strategy.long) 
     
if (exitSignal < 0 and exitSignal[1] < 0) 
    strategy.close_all()



// Minima/maxima delta
// plot(minimaDiff, style=plot.style_columns, color = (minimaDiff < 0 ? maximaDeltaColor : minimaDeltaColor))
// plot(minimaDiff, color = minimaDeltaColorInput)
// plot(maximaDiff, color = maximaDeltaColorInput)

// Price comparisons
// plot(priceAboveLastMinima, color = priceAboveMinimaColorInput)
// plot(priceAboveLastMaxima, color = priceAboveMaximaColorInput)

// Entry/exit signals
// plot(exitSignal, style=plot.style_columns, color = negativeFadedColor)
// plot(enterSignal, style=plot.style_columns, color = positiveFadedColor)

// plot(array.get(minimaHistory, 1), color = positiveColor)
// plot(minimaDiff, color = minimaDeltaColor)

// Minima/maxima presence
// plot(minimaFound / 2, style=plot.style_columns, color = negativeColor)
// plot(maximaFound / 2, style=plot.style_columns, color = positiveColor)
